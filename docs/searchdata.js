var SearchFiles = ["GUID-881040AE-0D5B-4230-8716-EDD19F4ACC3D.html",
							"GUID-BA554A7F-DEB8-4A5A-8812-FFFE14F65020.html",
							"GUID-A3D1F26A-7159-4A3F-9A3B-974D2BAB9B95.html",
							"GUID-08228661-66B9-4298-A542-A9882C7E70AC.html",
							"GUID-19B67E2D-FD6A-4902-BE08-8E8BA55B07D5.html",
							"GUID-B7F252F0-0B9C-4382-AD91-DAF1277CB236.html",
							"GUID-2FEE15A7-F8B7-4D89-9955-3EFE10903C5D.html",
							"GUID-E0DF7CAA-2654-411E-9B6B-0AAD81483829.html",
							"GUID-458C1313-CAD3-4A74-915B-331437224304.html",
							"GUID-789FBABD-423A-40FE-9246-E0875E4EC540.html",
							"GUID-4E6F799C-48CE-4787-B2F9-E4E051B60535.html",
							"GUID-DFE110AB-47FE-43F2-ACF2-B2C499BFA378.html",
							"GUID-136BD53F-F5E9-47C3-8D3B-58A8509CFE17.html",
							"GUID-14891D5C-8B73-4B92-A517-01887DB06E68.html",
							"GUID-6EDB97E9-092B-46A5-9FBF-38A056AAC5C5.html",
							"GUID-F4F039D0-481D-4E5E-BCA3-01084D73C216.html",
							"GUID-DA60B842-88F2-4B55-AAB6-28DDF959C1E4.html",
							"GUID-BCB6C96E-C12B-4367-AFC5-11DE2296B469.html",
							"GUID-7310FB9C-BB14-4BB4-8EBA-504CA0AB5783.html",
							"GUID-7310FB9C-BB14-4BB4-8EBA-504CA0AB5783.html",
							"GUID-D98906C7-7303-44BC-945E-3895937ED945.html",
							"GUID-9FF32589-7BC4-47A4-BCE8-AB3195696933.html",
							"GUID-7275D322-84BC-4310-BC78-35372820FA94.html",
							"GUID-39B3C6BD-375C-49B7-859A-E622F4C283D9.html",
							"GUID-21E61CA8-F941-4300-96F2-1ABE68C2E5AB.html",
							"GUID-B2968FB3-23F8-472A-AFEF-31F68759E1C9.html",
							"GUID-A91492F2-ADE8-4D7A-A5CA-ED9BB3B21311.html",
							"GUID-2F6E5181-F4D6-4174-9A3B-29423124DECA.html",
							"GUID-38FA6B2D-57DA-4937-BA18-90F2DCA92C94.html",
							"GUID-C5E7BBDB-F7E8-40A8-996F-7F8AE6B008C7.html",
							"GUID-2D5F9127-DC70-493E-9E2B-9CE0F159A9C5.html",
							"GUID-DA71EB0A-7016-49E2-BB0C-C16B8A638EAA.html",
							"GUID-285B7F9F-C3D0-4223-84D4-4559AC9DE45C.html",
							"GUID-D664142F-E3DC-4FB2-AFA0-E6BB9B6BBA38.html",
							"GUID-223F89A3-CABA-4004-B4EE-EBEB41A26C20.html",
							"GUID-223F89A3-CABA-4004-B4EE-EBEB41A26C20.html",
							"GUID-5589A6DE-5C57-4C1B-A686-A6D74FD54C5E.html",
							"GUID-A63AA7C7-ED9F-4FCF-8592-5ACDE85BFA93.html",
							"GUID-05593F9C-D5B5-45F0-8DC3-EDF5488B57A0.html",
							"GUID-2D2A6AC4-B699-4944-A452-0AABC1BEF5CE.html",
							"GUID-9C37C92A-D080-4E98-9864-FE7F3C0F3649.html",
							"GUID-D897FFEF-3FA5-4046-82FF-C88BF955BEA6.html",
							"GUID-6B323EDA-614A-4201-927B-F918B39A5801.html",
							"GUID-C2BE080F-AE0E-409C-B3EE-1F8BE3B6C57E.html",
							"GUID-545B6C94-BF80-4DE3-8C3C-4A98D92F5CBE.html",
							"GUID-1A32CB4B-CE63-4C56-B1A7-3C0AC22829AE.html",
							"GUID-BBA8F1A1-BFAD-4E06-A915-E9BB73A29131.html",
							"GUID-5CF51E51-E2C0-4BA6-BF10-0E3C8088CCD4.html",
							"GUID-7130628E-C1D2-450E-92BD-CC8D8228F08C.html",
							"GUID-83848FD5-F48B-47DB-A17A-7A8116CC540B.html",
							"GUID-B458B684-B082-47D1-8BE3-72BA6A35203C.html",
							"GUID-34CC2102-C031-4C70-9A24-E3434DF2DA4F.html",
							"GUID-19F1D13E-6B26-494B-AD54-1DFF7D64941B.html",
							"GUID-1486C6AF-64C9-4DFC-9D29-E078F932490A.html",
							"GUID-2AE43B44-2F6C-408D-AA33-F5D4D77E669B.html",
							"GUID-A2B796A2-D97F-460C-9344-349FE42BF4DC.html",
							"GUID-7ECDFAA5-505F-4506-BD5F-BB16E3873B4D.html",
							"GUID-993C2D51-1ECE-4F4D-9A02-206FF0F5EA90.html",
							"GUID-3D7CFE61-9064-41B5-B69D-E435AFE7ED1C.html",
							"GUID-EB28803B-2BB6-4EF3-B891-834D36C79DDA.html",
							"GUID-D20D6D1F-AC4F-48C5-97CC-8D49410AC9DB.html",
							"GUID-2D50D267-FDA7-4B04-A33A-A3AADC2A894D.html",
							"GUID-D6B4260F-94E1-4A2E-B24E-73E6ADB105DB.html",
							"GUID-41195D54-BB95-4252-A19F-87CA96A8B450.html",
							"GUID-115BCDEA-64D5-4115-9F4C-DE5C3CE39364.html"];

var SearchTitles = ["MPLAB® Harmony Class B Library for PIC32CM MC00 devices",
"CLASSB_CLOCK_DEFAULT_CLOCK_FREQ",
"CLASSB_CLOCK_ERROR_PERCENT",
"CLASSB_CLOCK_MAX_CLOCK_FREQ",
"CLASSB_CLOCK_MAX_SYSTICK_VAL",
"CLASSB_CLOCK_MAX_TEST_ACCURACY",
"CLASSB_CLOCK_MUL_FACTOR",
"CLASSB_CLOCK_RTC_CLK_FREQ",
"CLASSB_CLOCK_TEST_RTC_CYCLES",
"CLASSB_CLOCK_TEST_RTC_RATIO_NS",
"CLASSB_CLOCK_TEST_RATIO_NS_MS",
"CLASSB_COMPL_RESULT_ADDR",
"CLASSB_FLASH_CRC32_POLYNOMIAL",
"CLASSB_INTERRUPT_COUNT_VAR_ADDR",
"CLASSB_INTERRUPT_TEST_VAR_ADDR",
"CLASSB_INTR_DEVICE_VECT_OFFSET",
"CLASSB_INTR_MAX_INT_COUNT",
"CLASSB_INTR_TEST_RTC_COUNT",
"CLASSB_INTR_TEST_TC_COUNT",
"Data types",
"CLASSB_INTR_VECTOR_TABLE_SIZE",
"CLASSB_INVALID_TEST_ID",
"CLASSB_ONGOING_TEST_VAR_ADDR",
"CLASSB_RESULT_ADDR",
"CLASSB_SRAM_ALL_32BITS_HIGH",
"CLASSB_SRAM_APP_AREA_START",
"CLASSB_SRAM_BUFF_START_ADDRESS",
"CLASSB_SRAM_FINAL_WORD_ADDRESS",
"CLASSB_SRAM_STARTUP_TEST_SIZE",
"CLASSB_SRAM_TEMP_STACK_ADDRESS",
"CLASSB_TEST_IN_PROG_VAR_ADDR",
"CLASSB_WDT_TEST_IN_PROG_VAR_ADDR",
"CLASSB_SST_RESULT_BF",
"CLASSB_RST_RESULT_BF",
"CLASSB_CPU_PC_TEST_VALUES",
"Interface Routines",
"CLASSB_INIT_STATUS",
"CLASSB_PORT_INDEX",
"CLASSB_PORT_PIN",
"CLASSB_PORT_PIN_STATE",
"CLASSB_SRAM_MARCH_ALGO",
"CLASSB_STARTUP_STATUS",
"CLASSB_TEST_ID",
"CLASSB_TEST_STATUS",
"CLASSB_TEST_STATE",
"CLASSB_TEST_TYPE",
"CLASSB_App_WDT_Recovery",
"CLASSB_CPU_RegistersTest",
"CLASSB_CPU_PCTest",
"CLASSB_ClearTestResults",
"CLASSB_ClockTest",
"CLASSB_GetTestResult",
"CLASSB_FlashCRCGenerate",
"CLASSB_FlashCRCTest",
"CLASSB_GlobalsInit",
"CLASSB_IO_InputSamplingEnable",
"CLASSB_Init",
"CLASSB_SelfTest_FailSafe",
"CLASSB_SRAM_MarchTestInit",
"CLASSB_RST_IOTest",
"CLASSB_SRAM_TEST_BUFFER_SIZE",
"CLASSB_SST_InterruptTest",
"CLASSB_SST_WDT_Recovery",
"CLASSB_Startup_Tests",
"CLASSB_TestWDT"];

var SearchInfo = [" MPLAB® Harmony Class B Library for PIC32CM MC00 devices The Class B Library provides APIs to perform self-tests for the on-board systems of the microcontroller Features Tested by the Class B Library Following table shows the components tested by the Class B library Component Reference (Table H1 of IEC 60730-1) Fault/Error Acceptable Measures CPU Registers 1 1 Stuck-at Static memory test CPU Program Counter 1 3 Stuck-at Static memory test Interrupts 2 No interrupt / too frequent interrupt Functional test CPU Clock 3 Wrong frequency Frequency monitoring Flash 4 1 All single bit faults Modified checksum SRAM 4 2 DC fault Static memory test SRAM data path 5 1 Stuck-at Static memory test SRAM data path 5 2 Wrong address Static memory test Digital I/O 7 1 Abnormal operation Input comparison or output verification Class B Peripheral Library Usage This topic describes the basic architecture of the Class B library and provides information and examples on how to use it APIs defined by the Class B library can be used either by the start-up code or by the application code The application may use PLIBs drivers or middleware from the Harmony 3 software framework along with the Class B library code Abstraction Model The following picture shows positioning of Class B library in a Harmony 3 based application Start-up vs Run-time The Class B library contains many self-test routines those can be executed at startup and run-time If a self-test is executed at startup it is called as a Start-up Self-test (SST) and if it is executed at run-time then it is called a Run-time Self-test (RST) There are a few self-tests which can be used only as SST or as RST such self-tests have SST or RST in the API name eg: CLASSB_RST_IOTest()  CLASSB_SST_InterruptTest() If a self-test API does not have SST or RST in its name then it can be used at startup as well as runtime Start-up Self-test (SST) SSTs are used to test a component inside the microcontroller before it is initialized and used When the Class B library is added via MHC the selected SSTs are inserted into the _on_reset() function which is called from the Reset_Handler() This means that none of the data initialization could have happened before running SSTs So the Class B library initializes necessary variables before using them It is not mandatory to test all the components during startup The SRAM can be tested partially if a faster startup is needed by the application In this case modify the corresponding configuration macro ( CLASSB_SRAM_STARTUP_TEST_SIZE ) present in classb h file to change the size of the tested area Run-time Self-test (RST) RSTs can be used by the application during run-time to check safe operation of different components in the microcontroller These tests are non-destructive In the case of run-time tests the application shall decide which test to execute when Components in the Library The Class B library contains self-test routines for different components inside the CPU Critical and Non-critical Components Based on the impact of failure different components inside this Class B library are categorized as critical or non-critical If the self-test for CPU registers PC or Flash detects a failure the code execution is stopped and it remains in an infinite loop This is to prevent unsafe code execution In the case of non-critical components a failsafe function ( CLASSB_SelfTest_FailSafe ) is called when a failure is detected This function contains a software break point and an infinite loop Further code shall be added into this function as per the application need The failsafe function must not return to the Class B library since it is called due to a self-test failure Avoid use of features which depend on the failed component For example if self-test for clock is failed it is not advisable to use UART for error reporting as BAUD rate may not be accurate In the case of SRAM failure avoid the use of function calls or use of variables in SRAM A simple error reporting mechanism in this case of SRAM failure can be toggling of an IO pin Critical Components CPU registers including the Program Counter Internal Flash program memory Generic Flow of Critical Tests Non-critical Components CPU clock IO pins Internal SRAM Interrupts Generic Flow of Non-Critical Tests Self-tests for Components in the Library CPU Registers The ARM® Cortex®-M0+ is the CPU on the PIC32CM MC00 devices The Class B library checks the processor core registers for stuck-at faults The stuck-at condition causes register bit to remain at logic 0 or logic 1 Code execution should be stopped if this error condition is detected in any of the CPU registers This self-test follows the register save/restore convention specified by AAPCS It can be used at startup as well as run-time The Program Counter (PC) self-test is designed as a separate test since this register cannot be checked with usual test data patterns Flow chart of the self-test for CPU registers Program Counter (PC) The self-test for PC checks whether a stuck-at condition is present in the PC register The stuck-at condition causes register bit to remain at logic 0 or logic 1 Code execution should be stopped if this error condition is detected The self-test for PC calls multiple functions in predefined order and verifies that each function is executed and returns the expected value If the return values of all test functions are correct the Program Counter is assumed to be working fine This self-test can be used at startup as well as run-time Flow chart of the self-test for Program Counter (PC) Flash The internal flash memory of the device needs to be checked for proper functionality The self-test for internal flash performs CRC check on the internal flash memory of the device The address range is configurable for this self-test It runs CRC-32 algorithm with reversed representation of the polynomial 0x04C11DB7 and compares the generated checksum with the expected checksum It uses table-based approach where the table is generated during the execution This self-test uses a CRC-32 generation function This function is used inside the Class B library to generate CRC-32 of the internal Flash memory but it can be used on any contiguous memory area The flash self-test can be used at startup as well as run-time If this self-test is used during start up it must be ensured that the CRC of the application area is precalculated and stored at a specific memory address which is passed as an argument for the Flash self-test If this self-test detects a failure it remains in an infinite loop Flow chart of the self-test for internal flash program memory SRAM Self-test for the SRAM element looks for stuck-at faults DC faults and addressing faults with the help of RAM March algorithms One of the input arguments to this self-test selects the algorithm This self-test copies the data from the tested area of the SRAM into the reserved area in the SRAM and restore the data after the test Refer to section Configuring the Library for the details on reserving the SRAM The stack pointer is moved to the reserved area in the SRAM before running this self-test The SRAM self-test can be used at startup as well as run-time It provides three standard tests to detect error conditions March C March C minus March B Fault Coverage for March Algorithms Name Fault Coverage March C Addressing faults Stuck-at faults Transition faults all coupling faults March C- Unlinked addressing faults Stuck-at faults Transition faults all coupling faults March B Addressing faults Stuck-at faults Transition faults Linked idempotent coupling faults Linked inversion coupling faults Flow chart of the self-test for SRAM Flow chart of the internal routine for SRAM self-test Clock The self-test for CPU clock checks whether the CPU clock frequency is within the permissible range It uses RTC and SysTick to measure the CPU clock frequency The RTC is clocked at 32768 Hz from the 32 kHz External Crystal Oscillator and CPU clock can be from any other high frequency oscillator If the CPU clock frequency is within specified error limit it returns PASS The test duration is defined by one of the input arguments The clock self-test can be used at startup as well as run-time Note This self-test uses the RTC peripheral Thus if it is used during run-time the RTC shall not be used by the application for continuous modes such as real time clock or calendar If the RTC is used for some other purpose it must be reconfigured after running the clock self-test Keep the clock test duration lesser than the WDT timeout period to avoid the WDT resetting the device Flow chart of the self-test for CPU clock frequency Interrupt The self-test for this element checks the interrupts functionality of the microcontroller It configures the Nested Vectored Interrupt Controller (NVIC) the Real-Time Counter (RTC) and the Timer Counter 0 (TC0) peripherals to test the interrupt handling mechanism It verifies that at least one interrupt is generated and handled properly This self-test also checks whether the number of interrupts generated are too many within a given time period It reports a PASS if the RTC has generated at least one interrupt and the total number of interrupts generated by the TC0 is greater than one and less than the specified upper limit The clock used for RTC is 1kHz from the internal OSCULP32K and for TC0 the clock is same as the default CPU clock (48MHz from the DFLL48M) The interrupt self-test can be used only at startup Note This startup self-test utilizes the interrupts generated by RTC and TC0 For run-time testing of interrupts a separate self-test need to be developed Flow chart of the self-test for interrupts IO pin The self-test for IO pins verifies that any output pin is able to keep the configured logic state on the pin and any input pin is able to read the logic state present on the pin As the exact use of an IO pin is decide by the application it is the responsibility of the application to configure the IO pin direction and drive the pin to the expected state before calling this self-test Before testing an output pin call CLASSB_IO_InputSamplingEnable() function to enable input sampling for the IO pin When testing an input pin ensure that the IO pin is externally kept at a defined logic state The IO pin self-test can be used only at run-time Flow chart of the self-test for IO pins Class B Peripheral Library - Timing of self-tests Peripherals other than Flash and SRAM Name Time (in miroseconds) CLASSB_CPU_RegistersTest 14 CLASSB_CPU_PCTest 8 CLASSB_RST_IOTest 5 CLASSB_ClockTest 5100 CLASSB_SST_InterruptTest 9200 Flash and SRAM Name Time (in miroseconds) Tested size CLASSB_FlashCRCTest 12 32 KB CLASSB_SRAM_MarchTestInit 282 8 KB Note Timing is measured using onchip peripherals (SysTick and TC) at optimization level -O1 with CPU running at 48MHz from the internal 48MHz oscillator Before using these self-tests in an application it is recommended to check self-test timings with the required configuration (CPU clock compiler optimization memory size) Timing measured for CLASSB_SRAM_MarchTestInit using the ‘March C’ algorithm Following IDE and toolchain are used for timing measurements MPLAB X v5 50 XC32 Compiler v3 00 Configuring the Library (MPLAB X) This section provides details necessary to integrate the Class B library with other software components Optimization Requirements The self-test routines provides by the Class B software has specific optimization requirements which are listed in the following table If the optimization level for the project is different from what is listed in this table file level optimization has to be applied as per this table File Optimization Level classb_cpu_pc_test c classb_sram_algorithm c -O0 All other files ( h c S) -O1 or -O2 or -O3 Applying File Level Optimization MPLAB X Reserved SRAM area for the Class B library It is required to reserve 1kB of SRAM for exclusive use by the Class B library This reserved SRAM must not be accessed from outside the Class B library To check or update test results use the corresponding interface APIs When the Class B library is added into the project with the help of MHC the linker setting is modified by MHC as shown below In this example the PIC32CM1216MC00048 device with 16kB of SRAM is used -DRAM_ORIGIN=0x20000400 -DRAM_LENGTH=0x3C00 Modified Startup Sequence When generating project with help of MPLAB Harmony 3 the startup code is present in a file named startup_xc32 This file contains the Reset_Handler which has all startup code that runs before the main() function Initialization of the Class B library is done from the _on_reset function which is the first function to be executed from the Reset_Handler The function named CLASSB_Startup_Tests executes all startup self-tests inserted into classb c file by the MHC If none of the self-tests are failed this function returns CLASSB_STARTUP_TEST_PASSED If any of the startup self-tests are failed this function does not return becasue of the following reason In the case of critical failures (CPU registers or internal flash) the corresponding self-test remains in an infinite loop to avoid unsafe execution of code The self-tests for SRAM Clock and Interrupt are considered non-critical since it may be possible to execute a fail-safe function after detecting a failure In such case the CLASSB_SelfTest_FailSafe() function is called when a failure is detected Since the default implementation of CLASSB_SelfTest_FailSafe routine contains an infinite loop it won't return to the caller Note The library defines the _on_reset function and handles some of the reset causes The application developer shall insert functions to handle the rest of the reset causes WDT Test and Timeout The Watchdog timer is used as a recovery mechanism in case of software failures The Class B library enables the WDT and checks whether a WDT reset is issued if the timer is not cleared In CLASSB_Startup_Tests (in file classb c ) before performing startup self-tests the WDT timeout period is configured It can be modified after generating the project During startup the device runs from 4 MHz internal clock Before running any self-test which takes longer time (SRAM or Flash test) configuring the CPU clock at 48 MHz will help to recude the exection time If any of these self-tests takes more time than the WDT timeout period it results in a WDT reset Thus properly configuring the WDT period is essential during startup as well as runtime  Configuring Startup Tests via MHC Clone the classb_pic32cm_mc repo When an MPLAB Harmony 3 project is created the MHC lists all available components that can be added to the project The self-tests which need to run during startup can be configured via MHC The Configuration Options menu appears with a mouse click on the Class B Library component inside the Project Graph The configurations done via MHC does not configure the library instead it helps to modify the input arguments and to decide whether to run a specific test during startup Class B Library Interface Name Description Constants Summary CLASSB_CLOCK_DEFAULT_CLOCK_FREQ Default CPU clock speed CLASSB_CLOCK_ERROR_PERCENT Clock error percentage selected for startup test CLASSB_CLOCK_MAX_CLOCK_FREQ Maximum CPU clock speed CLASSB_CLOCK_MAX_SYSTICK_VAL Upper limit of SysTick counter CLASSB_CLOCK_MAX_TEST_ACCURACY Maximum detectable accuracy for clock self-test CLASSB_CLOCK_MUL_FACTOR Multiplication factor used in clock test CLASSB_CLOCK_RTC_CLK_FREQ RTC clock frequency CLASSB_CLOCK_TEST_RTC_RATIO_NS Duration of RTC clock in nano seconds CLASSB_CLOCK_TEST_RATIO_NS_MS Ratio of milli second to nano second CLASSB_COMPL_RESULT_ADDR Address of one's complement test results CLASSB_FLASH_CRC32_POLYNOMIAL CRC-32 polynomial CLASSB_INTERRUPT_COUNT_VAR_ADDR Address of the variable which keeps interrupt count CLASSB_INTERRUPT_TEST_VAR_ADDR Address of the variable which keeps interrupt test internal status CLASSB_INTR_DEVICE_VECT_OFFSET Defines the offset for first device specific interrupt CLASSB_INTR_MAX_INT_COUNT Defines the upper limit for interrupt count CLASSB_INTR_TEST_RTC_COUNT Defines the counter value for RTC peripheral CLASSB_INTR_TEST_TC_COUNT Defines the counter value for TC0 peripheral CLASSB_INTR_VECTOR_TABLE_SIZE Defines the size of the vector table CLASSB_INVALID_TEST_ID Invalid test ID CLASSB_ONGOING_TEST_VAR_ADDR Address at which the ID of ongoing test is stored CLASSB_RESULT_ADDR Address of test results CLASSB_SRAM_ALL_32BITS_HIGH Defines name for max 32-bit unsigned value CLASSB_SRAM_APP_AREA_START Defines the start address of the SRAM for the application CLASSB_SRAM_BUFF_START_ADDRESS SRAM test buffer start address CLASSB_SRAM_FINAL_WORD_ADDRESS Final word address in the SRAM CLASSB_SRAM_STARTUP_TEST_SIZE Size of the SRAM tested during startup CLASSB_SRAM_TEST_BUFFER_SIZE Defines the size of the buffer used for SRAM test CLASSB_SRAM_TEMP_STACK_ADDRESS Address of the temporary stack CLASSB_TEST_IN_PROG_VAR_ADDR Address of the variable which indicates that a Class B test is in progress CLASSB_WDT_TEST_IN_PROG_VAR_ADDR Address of the variable which indicates that a WDT test is in progress Data types Summary *CLASSB_SST_RESULT_BF Pointer to the structure for the Class B library startup self-test result This can be used to point to the result address 0x20000000 It will help to see the result in text form via watch window *CLASSB_RST_RESULT_BF Pointer to the structure for the Class B library run-time self-test result This can be used to point to the result address 0x20000004 It will help to see the result in text form via watch window CLASSB_CPU_PC_TEST_VALUES Data type for PC Test input and output values CLASSB_INIT_STATUS Identifies Class B initialization status CLASSB_PORT_INDEX PORT index definitions for Class B library I/O pin test CLASSB_PORT_PIN PIN definitions for Class B library I/O pin test CLASSB_PORT_PIN_STATE PORT pin state CLASSB_SRAM_MARCH_ALGO Selects the RAM March algorithm to run CLASSB_STARTUP_STATUS Identifies startup test status CLASSB_TEST_ID Identifies Class B library tests CLASSB_TEST_STATUS Identifies result from Class B library test CLASSB_TEST_STATE Identifies Class B library test state CLASSB_TEST_TYPE Identifies type of the Class B library test Interface Routines Summary CLASSB_App_WDT_Recovery This function is called if a WDT reset has happened during run-time CLASSB_CPU_RegistersTest This self-test checks the processor core registers CLASSB_CPU_PCTest This self-test checks the Program Counter register (PC) CLASSB_ClearTestResults Clears the results of SSTs or RSTs CLASSB_ClockTest This self-test checks whether the CPU clock frequency is within the permissible limit CLASSB_GetTestResult Returns the result of the specified self-test CLASSB_FlashCRCGenerate Generates CRC-32 checksum for a given memory area CLASSB_FlashCRCTest This self-test checks the internal Flash program memory to detect single bit faults CLASSB_GlobalsInit This function initializes the global variables for the classb library CLASSB_IO_InputSamplingEnable Enable input sampling for an IO pin CLASSB_Init This function is executed on every device reset This shall be called right after the reset before any other initialization is performed CLASSB_SelfTest_FailSafe This function is called if any of the non-critical tests detects a failure CLASSB_SRAM_MarchTestInit This self-test checks the SRAM with the help of RAM March algorithm CLASSB_SST_InterruptTest This self-test checks basic functionality of the interrupt handling mechanism CLASSB_SST_WDT_Recovery This function is called if a WDT reset has happened during the execution of an SST CLASSB_Startup_Tests This function executes all startup self-tests inserted into classb c file CLASSB_RST_IOTest This self-test can be used to perform plausibility checks on IO pins CLASSB_TestWDT This function tests the WatchDog Timer (WDT) ",
							" CLASSB_CLOCK_DEFAULT_CLOCK_FREQ Summary Default CPU clock speed Description Defines the default CPU clock speed after a reset Remarks This value must not be modified # define CLASSB_CLOCK_DEFAULT_CLOCK_FREQ (48000000U) ",
							" CLASSB_CLOCK_ERROR_PERCENT Summary Clock error percentage selected for startup test Description Defines the acceptable error percentage of the CPU clock This value is configured via MHC and is used during startup self-test of the CPU clock Remarks This value must not be modified # define CLASSB_CLOCK_ERROR_PERCENT (5U) ",
							" CLASSB_CLOCK_MAX_CLOCK_FREQ Summary Maximum CPU clock speed Description Defines the maximum CPU clock speed for the microcontroller Remarks This value must not be modified # define CLASSB_CLOCK_MAX_CLOCK_FREQ (120000000U) ",
							" CLASSB_CLOCK_MAX_SYSTICK_VAL Summary Upper limit of SysTick counter Description Defines the upper limit of SysTick counter Remarks This value must not be modified # define CLASSB_CLOCK_MAX_SYSTICK_VAL (0xffffffU) ",
							" CLASSB_CLOCK_MAX_TEST_ACCURACY Summary Maximum detectable accuracy for clock self-test Description Defines the maximum detectable accuracy for clock self-test Remarks This value must not be modified # define CLASSB_CLOCK_MAX_TEST_ACCURACY (5U) ",
							" CLASSB_CLOCK_MUL_FACTOR Summary Multiplication factor used in clock test Description Defines the multiplication factor used in clock test This is used to calculate the CPU clock error Used to avoid the use of floating point math Remarks This value must not be modified # define CLASSB_CLOCK_MUL_FACTOR (128U) ",
							" CLASSB_CLOCK_RTC_CLK_FREQ Summary RTC clock frequency Description Defines the RTC clock frequency Remarks This value must not be modified # define CLASSB_CLOCK_RTC_CLK_FREQ (32768U) ",
							" CLASSB_CLOCK_TEST_RTC_CYCLES Summary Duration of the CPU clock test Description Defines the duration of the CPU clock test in terms of RTC cycles Remarks This value must not be modified # define CLASSB_CLOCK_TEST_RTC_CYCLES (200U) ",
							" CLASSB_CLOCK_TEST_RTC_RATIO_NS Summary Duration of RTC clock in nano seconds Description Defines the duration of RTC clock in nano seconds This is used to calculate the duration of CPU clock test in terms of RTC cycles Remarks RTC is clocked from 32768 Hz Crystal One RTC cycle is 30517 nano sec This value must not be modified # define CLASSB_CLOCK_TEST_RTC_RATIO_NS (30517U) ",
							" CLASSB_CLOCK_TEST_RATIO_NS_MS Summary Ratio of milli second to nano second Description Defines the ratio of milli second to nano second This is used to calculate the duration of CPU clock test in terms of RTC cycles Remarks Used to avoid the use of floating point math This value must not be modified # define CLASSB_CLOCK_TEST_RATIO_NS_MS (1000000U) ",
							" CLASSB_COMPL_RESULT_ADDR Summary Address of one's complement test results Description This constant defines the address in SRAM where the one's complement of the test results are stored Remarks This value must not be modified # define CLASSB_COMPL_RESULT_ADDR (0x20000004U) ",
							" CLASSB_FLASH_CRC32_POLYNOMIAL Summary CRC-32 polynomial Description Defines the CRC-32 polynomial used for Flash self-test Remarks This value must not be modified # define CLASSB_FLASH_CRC32_POLYNOMIAL (0xedb88320U) ",
							" CLASSB_INTERRUPT_COUNT_VAR_ADDR Summary Address of the variable which keeps interrupt count Description Defines the address of the variable which keeps interrupt count Remarks This value must not be modified # define CLASSB_INTERRUPT_COUNT_VAR_ADDR (0x2000001cU) ",
							" CLASSB_INTERRUPT_TEST_VAR_ADDR Summary Address of the variable which keeps interrupt test internal status Description Defines the address of the variable which keeps interrupt test internal status Remarks This value must not be modified # define CLASSB_INTERRUPT_TEST_VAR_ADDR (0x20000018U) ",
							" CLASSB_INTR_DEVICE_VECT_OFFSET Summary Defines the offset for first device specific interrupt Description This constant defines the offset for first device specific interrupt Remarks This value must not be modified # define CLASSB_INTR_DEVICE_VECT_OFFSET (16U) ",
							" CLASSB_INTR_MAX_INT_COUNT Summary Defines the upper limit for interrupt count Description This constant defines the upper limit for interrupt count for the interrupt self-test Remarks This value must not be modified # define CLASSB_INTR_MAX_INT_COUNT (30U) ",
							" CLASSB_INTR_TEST_RTC_COUNT Summary Defines the counter value for RTC peripheral Description This constant defines the counter value for RTC peripheral for the interrupt self-test Remarks This value must not be modified # define CLASSB_INTR_TEST_RTC_COUNT (50U) ",
							" CLASSB_INTR_TEST_TC_COUNT Summary Defines the counter value for TC0 peripheral Description This constant defines the counter value for TC0 peripheral for the interrupt self-test Remarks This value must not be modified # define CLASSB_INTR_TEST_TC_COUNT (100U) ",
							" Data types ",
							" CLASSB_INTR_VECTOR_TABLE_SIZE Summary Defines the size of the vector table Description This constant defines the size of the vector table Remarks This value must not be modified # define CLASSB_INTR_VECTOR_TABLE_SIZE (CLASSB_INTR_DEVICE_VECT_OFFSET + PERIPH_MAX_IRQn) ",
							" CLASSB_INVALID_TEST_ID Summary Invalid test ID Description Defines a constant to initialize the variable which holds the ID of the ongoing self-test Remarks This value must not be modified # define CLASSB_INVALID_TEST_ID (0xFFU) ",
							" CLASSB_ONGOING_TEST_VAR_ADDR Summary Address at which the ID of ongoing test is stored Description This constant defines the address in SRAM where the the ID of ongoing test is stored Remarks This value must not be modified # define CLASSB_ONGOING_TEST_VAR_ADDR (0x20000008U) ",
							" CLASSB_RESULT_ADDR Summary Address of test results Description This constant defines the address in SRAM where the test results are stored Remarks This value must not be modified # define CLASSB_RESULT_ADDR (0x20000000U) ",
							" CLASSB_SRAM_ALL_32BITS_HIGH Summary Defines name for max 32-bit unsigned value Description This constant defines a name for max 32-bit unsigned value Remarks This value must not be modified # define CLASSB_SRAM_ALL_32BITS_HIGH (0xFFFFFFFFU) ",
							" CLASSB_SRAM_APP_AREA_START Summary Defines the start address of the SRAM for the application Description This constant defines the start address of the SRAM for the application First 1kB of the SRAM is reserved for the Class B library Remarks This value must not be modified # define CLASSB_SRAM_APP_AREA_START (0x20000400U) ",
							" CLASSB_SRAM_BUFF_START_ADDRESS Summary SRAM test buffer start address Description This constant defines the SRAM test buffer start address This is used by the self-test for the SRAM Remarks This value must not be modified # define CLASSB_SRAM_BUFF_START_ADDRESS (0x20000200U) ",
							" CLASSB_SRAM_FINAL_WORD_ADDRESS Summary Final word address in the SRAM Description This constant defines the final word address in the SRAM Remarks This value must not be modified Varies depending on the device # define CLASSB_SRAM_FINAL_WORD_ADDRESS (0x2003fffcU) ",
							" CLASSB_SRAM_STARTUP_TEST_SIZE Summary Size of the SRAM tested during startup Description Defines the size of the SRAM tested during startup Modify this macro to change the area of the tested SRAM area The test size must be a multiple of four Remarks This value can be modified # define CLASSB_SRAM_STARTUP_TEST_SIZE (65536U) ",
							" CLASSB_SRAM_TEMP_STACK_ADDRESS Summary Address of the temporary stack Description This constant defines the address of the temporary stack used during SRAM self-test Remarks This value must not be modified # define CLASSB_SRAM_TEMP_STACK_ADDRESS (0x20000100U) ",
							" CLASSB_TEST_IN_PROG_VAR_ADDR Summary Address of the variable which indicates that a Class B test is in progress Description Defines the address of the variable which indicates that a Class B test is in progress Remarks This value must not be modified # define CLASSB_TEST_IN_PROG_VAR_ADDR (0x2000000CU) ",
							" CLASSB_WDT_TEST_IN_PROG_VAR_ADDR Summary Address of the variable which indicates that a WDT test is in progress Description Defines the address of the variable which indicates that a WDT test is in progress Remarks This value must not be modified # define CLASSB_WDT_TEST_IN_PROG_VAR_ADDR (0x20000010U) ",
							" CLASSB_SST_RESULT_BF Summary Pointer to the structure for the Class B library startup self-test result Description For bit-field representation of Class B library test results Remarks None typedef  struct  { CLASSB_TEST_STATUS CPU_STATUS : 2 ; CLASSB_TEST_STATUS PC_STATUS : 2 ; CLASSB_TEST_STATUS RAM_STATUS : 2 ; CLASSB_TEST_STATUS FLASH_STATUS : 2 ; CLASSB_TEST_STATUS CLOCK_STATUS : 2 ; CLASSB_TEST_STATUS INTERRUPT_STATUS : 2 ;  }  * CLASSB_SST_RESULT_BF ; ",
							" CLASSB_RST_RESULT_BF Summary Pointer to the structure for the Class B library run-time self-test result Description For bit-field representation of Class B library test results Remarks None typedef  struct  { CLASSB_TEST_STATUS CPU_STATUS : 2 ; CLASSB_TEST_STATUS PC_STATUS : 2 ; CLASSB_TEST_STATUS RAM_STATUS : 2 ; CLASSB_TEST_STATUS FLASH_STATUS : 2 ; CLASSB_TEST_STATUS CLOCK_STATUS : 2 ; CLASSB_TEST_STATUS UNUSED_STATUS : 2 ; CLASSB_TEST_STATUS IO_STATUS : 2 ;  }  * CLASSB_RST_RESULT_BF ; ",
							" CLASSB_CPU_PC_TEST_VALUES Summary Data type for PC Test input and output values Description The PC tests performs logical left-shift of the input value and returns it Values from this enum can be used as arguments Remarks None typedef  enum  classb_pc_test_val  { CLASSB_CPU_PC_TEST_ROUTINE_A_INPUT =  1U  CLASSB_CPU_PC_ROUTINE_A_RET_VAL =  2U  CLASSB_CPU_PC_ROUTINE_B_RET_VAL =  4U  CLASSB_CPU_PC_ROUTINE_C_RET_VAL =  8U  CLASSB_CPU_PC_TEST_INIT_VAL =  0U  } CLASSB_CPU_PC_TEST_VALUES ; ",
							" Interface Routines ",
							" CLASSB_INIT_STATUS Summary Identifies Class B initialization status Description This is return type for the function which initializes the Class B library during startup This indicates whether the SSTs are executed or not Remarks None typedef  enum  { CLASSB_SST_DONE =  1  CLASSB_SST_NOT_DONE =  2  } CLASSB_INIT_STATUS ; ",
							" CLASSB_PORT_INDEX Summary PORT index definitions for Class B library I/O pin test Description This can be used in the I/O pin test Remarks None typedef  enum  { PORTA =  0  PORTB =  1  PORTC =  2   } CLASSB_PORT_INDEX ; ",
							" CLASSB_PORT_PIN Summary PIN definitions for Class B library I/O pin test Description This can be used in the I/O pin test Remarks None typedef  enum  { PIN0 =  0  PIN1 =  1  PIN2 =  2  PIN3 =  3  PIN4 =  4  PIN5 =  5  PIN6 =  6  PIN7 =  7  PIN8 =  8  PIN9 =  9  PIN10 =  10  PIN11 =  11  PIN12 =  12  PIN13 =  13  PIN14 =  14  PIN15 =  15  PIN16 =  16  PIN17 =  17  PIN18 =  18  PIN19 =  19  PIN20 =  20  PIN21 =  21  PIN22 =  22  PIN23 =  23  PIN24 =  24  PIN25 =  25  PIN26 =  26  PIN27 =  27  PIN28 =  28  PIN29 =  29  PIN30 =  30  PIN31 =  31  } CLASSB_PORT_PIN ; ",
							" CLASSB_PORT_PIN_STATE Summary PORT pin state Description This can be used in the I/O pin test Remarks None typedef  enum  { PORT_PIN_LOW =  0  PORT_PIN_HIGH =  1  PORT_PIN_INVALID =  2  } CLASSB_PORT_PIN_STATE ; ",
							" CLASSB_SRAM_MARCH_ALGO Summary Selects the RAM March algorithm to run Description Selects the RAM March algorithm to be used for the SRAM self-test Remarks None typedef  enum  { CLASSB_SRAM_MARCH_C =  0  CLASSB_SRAM_MARCH_C_MINUS =  1  CLASSB_SRAM_MARCH_B =  2  } CLASSB_SRAM_MARCH_ALGO ; ",
							" CLASSB_STARTUP_STATUS Summary Identifies startup test status Description This is return type for the function which calls all self-tests during startup Remarks None typedef  enum  { CLASSB_STARTUP_TEST_PASSED =  1  CLASSB_STARTUP_TEST_FAILED =  2  } CLASSB_STARTUP_STATUS ; ",
							" CLASSB_TEST_ID Summary Identifies Class B library tests Description This enumeration can be used to read the self-test status and update it Test ID corresponds to the bit position at which the 2-bit test result is stored Remarks None typedef  enum  { CLASSB_TEST_CPU =  0  CLASSB_TEST_PC =  2  CLASSB_TEST_RAM =  4  CLASSB_TEST_FLASH =  6  CLASSB_TEST_CLOCK =  8  CLASSB_TEST_INTERRUPT =  10  CLASSB_TEST_IO =  12  } CLASSB_TEST_ID ; ",
							" CLASSB_TEST_STATUS Summary Identifies result from Class B library test Description This is return type for self-tests Remarks None typedef  enum  { CLASSB_TEST_NOT_EXECUTED =  0  CLASSB_TEST_PASSED =  1  CLASSB_TEST_FAILED =  2  CLASSB_TEST_INPROGRESS =  3  } CLASSB_TEST_STATUS ; ",
							" CLASSB_TEST_STATE Summary Identifies Class B library test state Description This data type is used to update flags which indicates whether a test has started or not Remarks None typedef  enum  { CLASSB_TEST_NOT_STARTED =  0  CLASSB_TEST_STARTED =  1  } CLASSB_TEST_STATE ; ",
							" CLASSB_TEST_TYPE Summary Identifies type of the Class B library test Description There are two categories of test They are startup tests (SSTs) and run-time tests (RSTs) Test results for SSTs and RSTs are stored at separate locations in the SRAM Remarks None typedef  enum  { CLASSB_TEST_TYPE_SST =  0  CLASSB_TEST_TYPE_RST =  1  } CLASSB_TEST_TYPE ; ",
							" CLASSB_App_WDT_Recovery Function static  void  CLASSB_App_WDT_Recovery ( void ) ; Summary This function is called if a WDT reset is caused during run-time Description This function is used inside the CLASSB_Init() function When the device comes back from a WDT reset if a WDT test by the Class B library has not been in progress it is assumed that the WDT reset has happened since the application failed to clear the WDT during regular intervals In this case the CLASSB_App_WDT_Recovery() function is called from CLASSB_Init() Precondition None Parameters None Returns None Example if  ( ( RSTC_REGS - RSTC_RCAUSE  RSTC_RCAUSE_WDT_Msk )  == RSTC_RCAUSE_WDT_Msk )  {  if  (  ( * wdt_test_in_progress == CLASSB_TEST_STARTED ) )  {  CLASSB_SST_WDT_Recovery ( ) ;  }  } Remarks This function is for the internal use of the Class B library ",
							" CLASSB_CPU_RegistersTest Function CLASSB_TEST_STATUS CLASSB_CPU_RegistersTest ( bool running_context ) ; Summary This self-test checks the processor core registers of the CPU to detect stuck-at faults Description This self-test writes test patterns into the processor core registers and special function registers and read them back to detect stuck-at faults Special function register bits which are reserved or should not be modified during the test are not written Precondition None Parameters running_context - False for startup test True for run-time test Returns CLASSB_TEST_STATUS - Status of the test Example CLASSB_TEST_STATUS classb_test_status = CLASSB_TEST_NOT_EXECUTED ;  // Perform run-time test of the CPU registers classb_test_status =  CLASSB_CPU_RegistersTest ( true ) ; Remarks This self-test can be used during startup as well as run-time If a failure is detected this self-test remains in an infinite loop to avoid unsafe code execution ",
							" CLASSB_CPU_PCTest Function CLASSB_TEST_STATUS CLASSB_CPU_PCTest ( bool running_context ) ; Summary This self-test checks the Program Counter register (PC) of the CPU to detect stuck-at faults Description This self-test calls multiple functions in predefined order and verifies that each function is executed and returns the expected value If the return values of all test functions are correct the Program Counter is assumed to be working fine Precondition None Parameters running_context - False for startup test True for run-time test Returns CLASSB_TEST_STATUS - Status of the test Example CLASSB_TEST_STATUS classb_test_status = CLASSB_TEST_NOT_EXECUTED ;  // Perform run-time test of the PC classb_test_status =  CLASSB_CPU_PCTest ( true ) ; Remarks This self-test can be used during startup as well as run-time If a failure is detected this self-test remains in an infinite loop to avoid unsafe code execution ",
							" CLASSB_ClearTestResults Function void  CLASSB_ClearTestResults ( CLASSB_TEST_TYPE test_type ) ; Summary Clears the results of SSTs or RSTs Description This function clears all the test results of a given type of test Precondition None Parameters test_type - Can be CLASSB_TEST_TYPE_SST or CLASSB_TEST_TYPE_RST Returns None Example CLASSB_ClearTestResults ( CLASSB_TEST_TYPE_SST ) ;  CLASSB_ClearTestResults ( CLASSB_TEST_TYPE_RST ) ; Remarks This function is called from CLASSB_Init() ",
							" CLASSB_ClockTest Function CLASSB_TEST_STATUS CLASSB_ClockTest ( uint32_t cpu_clock_freq  uint8_t error_limit  uint16_t clock_test_rtc_cycles  bool running_context ) ; Summary This self-test checks whether the CPU clock frequency is within the permissible limit Description This self-test uses RTC and SysTick to measure the CPU clock frequency The RTC is clocked at 32768 Hz from the XOSC32K and CPU clock can be from any other high frequency oscillator If the CPU clock frequency is within specified error limit it returns PASS The test duration is defined by the value of rtc_cycles The RTC is configured to take clock from an external 32 768 kHz accurate crystal Precondition None Parameters cpu_clock_freq - Expected CPU clock frequency error_limit - Permissible error limit (eg; 5 means +-5 percent) clock_test_rtc_cycles - The test duration in terms of RTC cycles running_context - False for startup test True for run-time test Returns CLASSB_TEST_STATUS - Status of the test Example CLASSB_TEST_STATUS classb_test_status = CLASSB_TEST_NOT_EXECUTED ;  // Perform run-time test of the CPU clock classb_test_status =  CLASSB_ClockTest ( 120000000   5   500  true ) ; Remarks This self-test can be used during startup as well as run-time This self-test shall be used only if there is an external 32 768 kHz accurate crystal connected to the XOSC32K of the microcontroller ",
							" CLASSB_GetTestResult Function CLASSB_TEST_STATUS CLASSB_GetTestResult ( CLASSB_TEST_TYPE test_type  CLASSB_TEST_ID test_id ) ; Summary Returns the result of the specified self-test Description This function reads the test results from the reserved SRAM and extracts the result of the self-test specified by the input arguments Precondition None Parameters test_type - Can be CLASSB_TEST_TYPE_SST or CLASSB_TEST_TYPE_RST test_id - Identifier for a Class B library test Returns None Example CLASSB_TEST_STATUS classb_test_status = CLASSB_TEST_NOT_EXECUTED ; classb_test_status =  CLASSB_GetTestResult ( CLASSB_TEST_TYPE_SST  CLASSB_TEST_CPU ) ; Remarks None ",
							" CLASSB_FlashCRCGenerate Function uint32_t CLASSB_FlashCRCGenerate ( uint32_t start_addr  uint32_t test_size ) ; Summary Generates CRC-32 checksum for a given memory area Description This function runs CRC-32 algorithm with the polynomial 0xEDB88320 and returns the generated checksum It uses table based approach where the table is generated during the execution It uses 0xffffffff as the initial value Precondition None Parameters start_addr - Starting address of the memory block test_size - Size of the memory block Returns CLASSB_TEST_STATUS - Status of the test Example uint32_t crc_val =  0 ;  // Generate CRC-32 for the internal Flash crc_val =  CLASSB_FlashCRCGenerate ( 0   0xFE000 ) ; Remarks This function is used inside the Class B library to generate CRC-32 of the internal Flash memory but it can be used on any contiguous memory area ",
							" CLASSB_FlashCRCTest Function CLASSB_TEST_STATUS CLASSB_FlashCRCTest ( uint32_t start_addr  uint32_t test_size  uint32_t crc_val  bool running_context ) ; Summary This self-test checks the internal Flash program memory to detect single bit faults Description This self-test generates CRC-32 checksum for the given memory area and compares it with the expected checksum Precondition None Parameters start_addr - Starting address of the memory block test_size - Size of the memory block crc_val - Expected CRC-32 checksum running_context - False for startup test True for run-time test Returns CLASSB_TEST_STATUS - Status of the test Example CLASSB_TEST_STATUS classb_test_status = CLASSB_TEST_NOT_EXECUTED ;  // Perform run-time test of the internal Flash classb_test_status =  CLASSB_FlashCRCTest ( 0   0xFE000   * ( uint32_t * ) FLASH_CRC32_ADDR  true ) ; Remarks This self-test can be used during startup as well as run-time If a failure is detected this self-test remains in an infinite loop to avoid unsafe code execution ",
							" CLASSB_GlobalsInit Function static  void  CLASSB_GlobalsInit ( void ) ; Summary This function initializes the global variables for the classb library Description The parameters used by the Class B library are access with the help of pointer variables These variables are initialized by this function Precondition None Parameters None Returns None Example CLASSB_GlobalsInit ( ) ; Remarks None ",
							" CLASSB_IO_InputSamplingEnable Function void  CLASSB_IO_InputSamplingEnable ( CLASSB_PORT_INDEX port  CLASSB_PORT_PIN pin ) ; Summary Enable input sampling for an IO pin Description Before testing an output pin with CLASSB_RST_IOTest() API call this function to enable input sampling so that the 'IN' register will have the data from the port pin Precondition None Parameters port - Index of the IO PORT Defined by enum CLASSB_PORT_INDEX pin - Index of the pin on the given PORT Defined by enum CLASSB_PORT_PIN state - Expected logic state of the IO pin It can be PORT_PIN_LOW or PORT_PIN_HIGH Returns CLASSB_TEST_STATUS - Status of the test Example CLASSB_TEST_STATUS classb_test_status = CLASSB_TEST_NOT_EXECUTED ;  // Perform test of an IO pin at run-time classb_test_status =  CLASSB_RST_IOTest ( PORTB  PIN31  PORT_PIN_HIGH ) ; Remarks This self-test can be used only during run-time ",
							" CLASSB_Init Function static CLASSB_INIT_STATUS CLASSB_Init ( void ) ; Summary This function is executed on every device reset This shall be called right after the reset before any other initialization is performed Description This function performs the following a It initializes the global variables used by the Class B library b Checks the reset cause and decides next course of action c If the reset is not caused by the Class B library it tests the reserved SRAM area clears all self-test results and performs a WDT test Precondition None Parameters None Returns CLASSB_SST_DONE if all SSTs are successfully executed CLASSB_SST_NOT_DONE if SSTs are yet to be executed Example CLASSB_INIT_STATUS init_status =  CLASSB_Init ( ) ; Remarks None ",
							" CLASSB_SelfTest_FailSafe Function void  CLASSB_SelfTest_FailSafe ( CLASSB_TEST_ID test_id ) ; Summary This function is called if any of the non-critical tests are failed Description The self-tests for SRAM Clock and Interrupt are considered non-critical since it may be possible to execute a fail-safe function after detecting a failure if the fail-safe routine does not use the failed element on the microcontroller Default implementation of this function is available in classb c file The function contains an infinite loop Further code shall be added as per the application need Precondition None Parameters test_id - Identification number of the failed test Returns None Example if  ( classb_sram_status == CLASSB_TEST_FAILED )  {  CLASSB_SelfTest_FailSafe ( CLASSB_TEST_RAM ) ;  } Remarks This function must not return to the Class B library since it is called due to a self-test failure Avoid using features which depend on the failed component For example if self-test for clock is failed it is not advisable to use UART for error reporting since BAUD rate may not be accurate In the case of SRAM failure avoid the use of function calls or variables in SRAM The error reporting mechanism in this case can be an IO pin ",
							" CLASSB_SRAM_MarchTestInit Function CLASSB_TEST_STATUS CLASSB_SRAM_MarchTestInit ( uint32_t * start_addr  uint32_t test_size  CLASSB_SRAM_MARCH_ALGO march_algo  bool running_context ) ; Summary This self-test checks the SRAM with the help of RAM March algorithm Description This self-test run the selected RAM March algorithm on the SRAM to detect stuck-at fault DC fault and addressing fault Precondition None Parameters start_addr - Starting address of the memory block test_size - Size of the memory block march_algo - The selected RAM March algorithm It can be March C March C minus or March B running_context - False for startup test True for run-time test Returns CLASSB_TEST_STATUS - Status of the test Example CLASSB_TEST_STATUS classb_test_status = CLASSB_TEST_NOT_EXECUTED ;  // Perform run-time test of the internal SRAM classb_test_status =  CLASSB_SRAM_MarchTestInit ( ( uint32_t * ) CLASSB_SRAM_APP_AREA_START   1024  CLASSB_SRAM_MARCH_C  true ) ; Remarks This self-test can be used during startup as well as run-time Initial 1kB of the SRAM must be reserved for the Class B library ",
							" CLASSB_RST_IOTest Function CLASSB_TEST_STATUS CLASSB_RST_IOTest ( CLASSB_PORT_INDEX port  CLASSB_PORT_PIN pin  CLASSB_PORT_PIN_STATE state ) ; Summary This self-test can be used to perform plausibility checks on IO pins Description This self-test checks whether a given IO pin is at the expected logic state As the exact use of an IO pin is decide by the application it is the responsibility of the caller to configure the IO pin direction and drive the pin to the expected state before calling this self-test Precondition Before testing an output pin call CLASSB_IO_InputSamplingEnable() function to enable input sampling for the IO pin Parameters port - Index of the IO PORT Defined by enum CLASSB_PORT_INDEX pin - Index of the pin on the given PORT Defined by enum CLASSB_PORT_PIN state - Expected logic state of the IO pin It can be PORT_PIN_LOW or PORT_PIN_HIGH Returns CLASSB_TEST_STATUS - Status of the test Example CLASSB_TEST_STATUS classb_test_status = CLASSB_TEST_NOT_EXECUTED ;  // Perform test of an IO pin at run-time classb_test_status =  CLASSB_RST_IOTest ( PORTB  PIN31  PORT_PIN_HIGH ) ; Remarks This self-test can be used only during run-time ",
							" CLASSB_SRAM_TEST_BUFFER_SIZE Summary Defines the size of the buffer used for SRAM test Description This constant defines the size of the buffer used for SRAM test Remarks This value must not be modified # define CLASSB_SRAM_TEST_BUFFER_SIZE (512U) ",
							" CLASSB_SST_InterruptTest Function CLASSB_TEST_STATUS CLASSB_SST_InterruptTest ( void ) ; Summary This self-test checks basic functionality of the interrupt handling mechanism Description This self-test configures the Nested Vectored Interrupt Controller (NVIC) the RTC peripheral and the TC0 peripheral to test the interrupt handling mechanism of the microcontroller It verifies that at least one interrupt is generated and handled properly This self-test also checks whether the number of interrupts generated are too many within a given time period It reports a PASS if the RTC has generated at least one interrupt and the total number of interrupts generated by the TC0 is less than the specified upper limit and greater than one The clock used for RTC is 1kHz from the internal OSCULP32K and for TC0 the clock is same as the default CPU clock (48MHz from the DFLL48M) Precondition None Parameters None Returns CLASSB_TEST_STATUS - Status of the test Example CLASSB_TEST_STATUS classb_test_status = CLASSB_TEST_NOT_EXECUTED ;  // Perform test of the Interrupt mechanism at start-up classb_test_status =  CLASSB_SST_InterruptTest ( ) ; Remarks This self-test can be used only during startup ",
							" CLASSB_SST_WDT_Recovery Function static  void  CLASSB_SST_WDT_Recovery ( void ) ; Summary This function is called if a WDT reset is caused while a startup self-test is running Description This function is used inside the CLASSB_Init() function When the device comes back from a WDT reset if there has been a startup self-test running it is assumed that the WDT reset has happened because a Class B self-test has taken more time that the WDT timeout period In this case the CLASSB_SST_WDT_Recovery() function is called from CLASSB_Init() Precondition None Parameters None Returns None Example if  ( ( RSTC_REGS - RSTC_RCAUSE  RSTC_RCAUSE_WDT_Msk )  == RSTC_RCAUSE_WDT_Msk )  {  if  ( * classb_test_in_progress == CLASSB_TEST_STARTED )  {  CLASSB_SST_WDT_Recovery ( ) ;  }  } Remarks This function is for the internal use of the Class B library ",
							" CLASSB_Startup_Tests Function static CLASSB_STARTUP_STATUS CLASSB_Startup_Tests ( void ) ; Summary This function executes all startup self-tests inserted into classb c file by the MHC Description This function is called from the '_on_reset' function which is the first function to be executed after a reset If none of the self-tests are failed this function returns 'CLASSB_STARTUP_TEST_PASSED' If any of the startup self-tests are failed this function will not return The self-tests for SRAM Clock and Interrupt are considered non-critical since it may be possible to execute a fail-safe function after detecting a failure In such case the CLASSB_SelfTest_FailSafe() function is called when a failure is detected In the case of critical failures (CPU registers or internal flash) the corresponding self-test remains in an infinite loop to avoid unsafe execution of code Precondition None Parameters None Returns Pass or Fail Example CLASSB_STARTUP_STATUS startup_tests_status = CLASSB_STARTUP_TEST_FAILED ; startup_tests_status =  CLASSB_Startup_Tests ( ) ; Remarks This function does not return if any of the self-tests detects a failure ",
							" CLASSB_TestWDT Function static  void  CLASSB_TestWDT ( void ) ; Summary This function tests the WatchDog Timer (WDT) Description This function is called from CLASSB_Init() It tests whether the WDT can reset the device After the WDT resets the device the Class B library clears the test flag and proceeds to the rest of the initialization routines Since the test flag is kept in reserved SRAM area it is not touched by the general startup code Precondition None Parameters None Returns None Example CLASSB_TestWDT ( void ) ; Remarks Calling this function results in device reset by the WDT "];

